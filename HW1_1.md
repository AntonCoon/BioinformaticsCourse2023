# BioinformaticsCourse2023
HW 1_1

+ [Task1](#Task1)
+ [Task2](#Task2)
+ [Task3](#Task3)
+ [Parsing data from fasta](#Parsing-data-from-fasta)

# Task1

## Хэмминг (1 балл)
Реализуйте вычисление расстояния Хэмминга.


```python
def hamming1(a: str, b: str):
    distance = 0
    if len(a) != len(b):
        raise ValueError('strings of different lengths!')
    for a_i, b_i in zip(a, b):
        if a_i != b_i:
            distance += 1
    return distance
```

# Task2

## Ближайшая подстрока (1 балл)
Даны 2 строки над алфавитом ATGC, реализуйте алгоритм, который позволит находить подстроку в более длинной строке, которая ближе всего по расстоянию Хэмминга к более короткой. Верните позицию начала этой подстроки, саму подстроку и расстояние Хэмминга.

```python
def nearest_substring(a: str, b: str):
    n, m = len(a), len(b)
    substrings = [b[i: i + n] for i in range(0, m - n + 1)]
    return min((i, substring, hamming1(a, substring))
               for i, substring in enumerate(substrings))
```

# Task3

## Левенштейн (4 балла)
Реализуйте алгоритм вычисления расстояния редактирования. O(n•m) по времени и O(min(n, m)) по памяти (обратите внимание на то, что возвращать способ получения из одной строки другую не нужно). Алгоритм возвращаеет одно число - расстояние редактирования между входными строками.
```python
def levenstein(a: str, b: str):
    n, m = len(a), len(b)
    if n > m:
        a, b = b, a
        n, m = m, n
    current_dp = range(n + 1)
    for i in range(1, m + 1):
        previous_dp = current_dp
        current_dp = [i] + [0] * n
        for j in range(1, n + 1):
            insertions = previous_dp[j] + 1
            deletions = current_dp[j - 1] + 1
            substitutions = previous_dp[j - 1]
            if a[j - 1] != b[i - 1]:
                substitutions += 1
            current_dp[j] = min(insertions, deletions, substitutions)
    return current_dp[n]
```

# Parsing data from fasta
```python
import fastaparser


storage1, storage2 = [], []
with open("f8.fasta") as fasta_file:
    parser = fastaparser.Reader(fasta_file)
    for seq in parser:
        storage1.append(seq.sequence_as_string())

with open("gattaca.fasta") as fasta_file:
    parser = fastaparser.Reader(fasta_file)
    for seq in parser:
        storage2.append(seq.sequence_as_string())

a1, b1 = storage1[0], storage1[1]
a2, b2 = storage2[0], storage2[1]
```
