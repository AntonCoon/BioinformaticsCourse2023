# BioinformaticsCourse2023
HW 1_1

+ [Task1](#Task1)
+ [Task2](#Task2)
+ [Task3](#Task3)
+ [Parsing data from fasta](#Parsing-data-from-fasta)

# Task1

## Хэмминг (1 балл)
Реализуйте вычисление расстояния Хэмминга.


```python
def hamming1(a: str, b: str):
    distance = 0
    if len(a) != len(b):
        raise ValueError('strings of different lengths!')
    for a_i, b_i in zip(a, b):
        if a_i != b_i:
            distance += 1
    return distance
```

# Task2

## Ближайшая подстрока (1 балл)
Даны 2 строки над алфавитом ATGC, реализуйте алгоритм, который позволит находить подстроку в более длинной строке, которая ближе всего по расстоянию Хэмминга к более короткой. Верните позицию начала этой подстроки, саму подстроку и расстояние Хэмминга.

```python
def nearest_substring(a: str, b: str):
    n, m = len(a), len(b)
    substrings = [b[i: i + n] for i in range(0, m - n + 1)]
    return min((i, substring, hamming1(a, substring))
               for i, substring in enumerate(substrings))
```

# Task3

## Левенштейн (4 балла)
Реализуйте алгоритм вычисления расстояния редактирования. O(n•m) по времени и O(min(n, m)) по памяти (обратите внимание на то, что возвращать способ получения из одной строки другую не нужно). Алгоритм возвращаеет одно число - расстояние редактирования между входными строками.
```python
import numpy as np


def levenstein(a: str, b: str):
    n, m = len(a), len(b)
    d = np.zeros((m, n))
    for i in range(1, n - 1):
        d[0][i] = d[0][i - 1] + 1
    for j in range(1, m - 1):
        d[j][0] = d[i - 1][0] + 1
    for i in range(1, m):
        for j in range(1, n):
            if a[i - 1] != b[j - 1]:
                d[i][j] = min(d[i - 1][j] + 1,
                              d[i][j - 1] + 1,
                              d[i - 1][j - 1] + 1)
            else:
                d[i][j] = d[i - 1][j - 1]
    return int(d[m - 1][n - 1])
```

# Parsing data from fasta
```python
import fastaparser


storage1, storage2 = [], []
with open("f8.fasta") as fasta_file:
    parser = fastaparser.Reader(fasta_file)
    for seq in parser:
        storage1.append(seq.sequence_as_string())

with open("gattaca.fasta") as fasta_file:
    parser = fastaparser.Reader(fasta_file)
    for seq in parser:
        storage2.append(seq.sequence_as_string())

a1, b1 = storage1[0], storage1[1]
a2, b2 = storage2[0], storage2[1]
```
